<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://davidyangblog.github.io</id>
    <title>杨的胸</title>
    <updated>2021-06-11T03:42:36.416Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://davidyangblog.github.io"/>
    <link rel="self" href="https://davidyangblog.github.io/atom.xml"/>
    <subtitle>大梦一场</subtitle>
    <logo>https://davidyangblog.github.io/images/avatar.png</logo>
    <icon>https://davidyangblog.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 杨的胸</rights>
    <entry>
        <title type="html"><![CDATA[如何用 JavaScript 写一个 URL 拼接方法？]]></title>
        <id>https://davidyangblog.github.io/post/ru-he-yong-javascript-xie-yi-ge-url-pin-jie-fang-fa/</id>
        <link href="https://davidyangblog.github.io/post/ru-he-yong-javascript-xie-yi-ge-url-pin-jie-fang-fa/">
        </link>
        <updated>2021-06-09T02:45:08.000Z</updated>
        <summary type="html"><![CDATA[<p>「如何」系列第五篇，五个步骤完成了一道经典前端面试题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>「如何」系列第五篇，五个步骤完成了一道经典前端面试题。</p>
<!-- more -->
<h1 id="前言">前言</h1>
<p>URL 拼接是一个经典的前端面试题，它除了考察面试者对各种边界情况考虑的细致程度，也涉及到【数组方法】、【原型链】等基本知识。</p>
<h1 id="一-问题">一、问题</h1>
<p>现有一串<code>url</code>（string 类型），和一个查询对象<code>newQuery</code>（JSON ），请编写一个函数，输入<code>url</code>和<code>newQuery</code>，输出新的<code>url</code>：</p>
<pre><code class="language-js">const newQuery = {
    a:1,
    b:&quot;NewString&quot;,
    d:&quot;?&amp;*:;&quot;,
    e:[11,22,33],
    f:false,
    g:null,
    h:undefined
}

const url = &quot;http://example.com/pathname/query?d=1&amp;e=2&quot;

function concatQuery = (url,newQuery)=&gt;{
    //...
    return newUrl
}
</code></pre>
<h1 id="二-分析">二、分析</h1>
<p><strong>流程图</strong></p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/yxon123/gitee-sources/raw/master//Images/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(2).png" alt="未命名文件 (2)" loading="lazy"></figure>
<p><strong>坑点</strong></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9749845"><label class="task-list-item-label" for="task-item-9749845"> 输入是否为空？==> JavaScript 空值检测/空对象检测</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2674203"><label class="task-list-item-label" for="task-item-2674203"> 新旧 query 部分是否有重名？==> 利用对象键值的唯一性去重</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-288"><label class="task-list-item-label" for="task-item-288"> 特殊字符处理 ==> 正则过滤特殊字符/url 内容转义</label></li>
</ul>
<h1 id="三-步骤详解">三、步骤详解</h1>
<h2 id="31-第一步空值检测">3.1 第一步：空值检测</h2>
<pre><code class="language-js">function concatQuery(){
    if(!url){
        return 'The origin url is empty'
    }
    if(newQuery.toString()=='{}'){
        return url
    }else{
		//...
    }
}
</code></pre>
<p>注意对<code>newQuery</code>判断的方法，因为涉及到隐式转换，<code>if(value)</code>和<code>if(value==true)</code>不适宜于判断空对象，会出现像下面这个例子展示的问题：</p>
<pre><code class="language-js">let empty = {}
let result = ''

if(empty==true){
    result = 'It is true'
}else if (empty==false){
    result = 'It is false'
}else if (!empty){
    result = '×'
}else if (empty){
    result = '√'
}
console.log(result)// =&gt; '√'
</code></pre>
<p>所以，</p>
<ol>
<li>检测<code>url</code>是否为<strong>空字符串</strong>，可以直接使用原值判断</li>
<li>检测<code>newQuery</code>是否为<strong>空对象</strong>，可以使用
<ol>
<li><code>Object.prototype.tostring.call(newQuery)</code>或<code>newQuery.toString()</code></li>
<li><code>JSON.stringfy(newQuery)</code></li>
</ol>
</li>
</ol>
<h2 id="32-第二步原-url-解析">3.2 第二步：原 url 解析</h2>
<pre><code class="language-js">const url = &quot;http://example.com/pathname/query?d=1&amp;e=2&quot;
</code></pre>
<p>要解析如上的<code>url</code>输入，我们需要对其进行预处理，拆分为两个部分</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/yxon123/gitee-sources/raw/master//Images/url%20(1).png" alt="url (1)" loading="lazy"></figure>
<p>在浏览器实现中，有一种巧妙的方式来拆分原<code>url</code></p>
<pre><code class="language-js">var parser = document.createElement('a');      
parser.href = &quot;http://example.com/pathname/query?d=1&amp;e=2&quot;
 
parser.origin; // =&gt; &quot;http://example.com&quot;
parser.pathname; // =&gt; &quot;/pathname/query&quot;    
parser.search;   // =&gt; &quot;?d=1&amp;e=2&quot;  

let urlLocation = parser.origin + parser.pathname
let queryString = parser.search.slice(1)//截取问号后的部分
</code></pre>
<p>当然，也可以直接使用<code>?</code>作为分隔符来拆分</p>
<pre><code class="language-js">const url = &quot;http://example.com/pathname/query?d=1&amp;e=2&quot;
let splitUrl = url.split('?') 
// =&gt; [&quot;http://example.com/pathname/query&quot;, &quot;d=1&amp;e=2&quot;]

let urlLocation = splitUrl[0]
let queryString = splitUrl[1]
</code></pre>
<p>对于得到的<code>query</code>部分的字符串，再对其进行对象化</p>
<pre><code class="language-js">let queryObj = {}
let queryArray = queryString.split('&amp;')
// =&gt;  [&quot;d=1&quot;, &quot;e=2&quot;]

for (let value of queryArray){
    valueArray = value.split('=')
    queryObj[valueArray[0]] = valueArray[1]
}

console.log(queryObj) 
// =&gt; {d:&quot;1&quot;, e=&quot;2&quot;}
</code></pre>
<p>到这一步我们就完成了对原url的所有解析过程，网上找了一下，有一些url解析的<a href="https://github.com/websanova/js-url">轮子</a>，但普遍不包含query字符串部分的解析，因为这部分大概率是后端的业务场景。</p>
<h2 id="33-第三步对象合并">3.3 第三步：对象合并</h2>
<p>接下来需要去合并新旧两个<code>query</code>对象，使用析构操作符<code>...</code>，可以对两个可能存在同名属性的对象进行<strong>去重+合并</strong>。</p>
<pre><code class="language-js">let queryObj = {
    a:undefined,
    b:&quot;OldString&quot;,
    c:5,
    d:&quot;DDDD&quot;
}

const newQuery = {
    a:1,
    b:&quot;NewString&quot;,
    d:&quot;?&amp;*:;&quot;,
    e:[11,22,33],
    f:false,
    g:null,
    h:undefined
}

queryObj = {
    ...queryObj,
    ...newQuery
}
/*
 ==&gt;
{
    a: 1,
    b: &quot;2&quot;,
    c: 5,
    d: &quot;?&amp;*:;&quot;,
    e: [11, 22, 33],
    f: false,
    g: null,
    h: undefined
}
*/
</code></pre>
<h2 id="34-第四步字符串生成">3.4 第四步：字符串生成</h2>
<pre><code class="language-js">const queryObj = {    a: 1,    b: &quot;2&quot;,    c: 5,    d: &quot;?&amp;*:;&quot;,    e: [11, 22, 33],    f: false,    g: null,    h: undefined}
</code></pre>
<p>这一步是<code>3.2 原 url 解析</code>的逆过程，需要将新生成的<code>query</code>对象转成字符串，对于每个需要传递的字段，</p>
<p>使用<code>encodeURIComponent()</code>进行一次转义：</p>
<pre><code class="language-js">let newQueryString = &quot;&quot;for(let key in queryObj){    let valueStr = Object.prototype.toString.call(queryObj[key])    // 过滤掉值为 null 或者 undifined 的字段，将其余字段拼接    if(valueStr!=&quot;[object Null]&quot;&amp;&amp; valueStr!=&quot;[object Undefined]&quot;){        newQueryString = newQueryString + key + &quot;=&quot; + encodeURIComponent(queryObj[key]) + &quot;&amp;&quot;     }}console.log(newQueryString)// =&gt; a=1&amp;b=2&amp;c=5&amp;d=%3F%26*%3A%3B&amp;e=11%2C22%2C33&amp;f=false&amp;
</code></pre>
<h2 id="35-第五步-url-生成">3.5 第五步： url 生成</h2>
<p>将<code>3.2 第二步</code>中拆分放在一边的<code>urlLocation</code>与新生成的<code>queryString</code>进行合并然后输出</p>
<pre><code class="language-js">//urlLocation = &quot;http://example.com/pathname/query&quot;//queryString = &quot;a=1&amp;b=2&amp;c=5&amp;d=%3F%26*%3A%3B&amp;e=11%2C22%2C33&amp;f=false&amp;&quot;let newUrl = urlLocation + &quot;?&quot; + newQueryStringreturn newUrl
</code></pre>
<h2 id="36-完整代码">3.6 完整代码</h2>
<p>大功告成！完整代码如下：</p>
<pre><code class="language-js">const newQuery = {    a:1,    b:&quot;NewString&quot;,    d:&quot;?&amp;*:;&quot;,    e:[11,22,33],    f:false,    g:null,    h:undefined}const url = &quot;http://example.com/pathname/query?d=1&amp;e=2&quot;function concatQuery(url, newQuery){    if(!url){        return 'The origin url is empty'    }    if(newQuery.toString()=='{}'){        return url    }else{            let splitUrl = url.split('?')             let urlLocation = splitUrl[0]            let queryString = splitUrl[1]            let queryObj = {}            let queryArray = queryString.split('&amp;')            for (let value of queryArray){                valueArray = value.split('=')                queryObj[valueArray[0]] = valueArray[1]            }            queryObj = {                ...queryObj,                ...newQuery            }            let newQueryString = &quot;&quot;            for(let key in queryObj){                let valueStr = Object.prototype.toString.call(queryObj[key])                if(valueStr!=&quot;[object Null]&quot;&amp;&amp; valueStr!=&quot;[object Undefined]&quot;){                    newQueryString = newQueryString + key + &quot;=&quot; + encodeURIComponent(queryObj[key]) + &quot;&amp;&quot;                 }            }            let newUrl = urlLocation + &quot;?&quot; + newQueryString            return newUrl    }}let newUrl = concatQuery(url, newQuery)console.log(newUrl)
</code></pre>
<h1 id="四-总结">四、总结</h1>
<p>代码不长，但花了我很长时间来查证细节，发现自己对一些数组方法熟悉程度还是不够，比如数组和字符串有一些方法同名且用法类似（比如<code>indexof</code>，<code>slice</code>），有一些则不通用（比如属于数组的<code>splice</code>），具体可以参考<a href="https://www.cnblogs.com/jing-tian/p/12067632.html">另一篇文章</a>。另外，对于原<code>url</code>不含query的情况没有在文章中展现，只需要在<code>3.2 第二步</code>中加一层判断即可，此处不再赘述。</p>
<p><strong>参考</strong></p>
<p><a href="https://www.runoob.com/jsref/jsref-encodeuricomponent.html">JavaScript encodeURIComponent() 函数</a></p>
<p><a href="https://www.cnblogs.com/jing-tian/p/12067632.html">js数组与字符串类型相同方法的比较</a></p>
<p><a href="https://www.jianshu.com/p/bc4f25f9e087/">JS中解析URL的简单方法</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何判断 JavaScript 数据类型？]]></title>
        <id>https://davidyangblog.github.io/post/ru-he-pan-duan-javascript-shu-ju-lei-xing/</id>
        <link href="https://davidyangblog.github.io/post/ru-he-pan-duan-javascript-shu-ju-lei-xing/">
        </link>
        <updated>2021-06-08T02:59:33.000Z</updated>
        <summary type="html"><![CDATA[<p>「如何」系列第四篇，分析了四种判断JavaScript数据类型的方法，总结了1个判断思路。</p>
]]></summary>
        <content type="html"><![CDATA[<p>「如何」系列第四篇，分析了四种判断JavaScript数据类型的方法，总结了1个判断思路。</p>
<!-- more -->
<h2 id="一-问题">一、问题</h2>
<p>在 ECMAScript 规范中，共定义了 7 种数据类型，分为 基本类型 和 引用类型 两大类，如下所示：</p>
<blockquote>
<p><strong>基本类型</strong>：String、Number、Boolean、Symbol、Undefined、Null</p>
<p><strong>引用类型</strong>：Object</p>
</blockquote>
<p>ECMAScript 采用的是松散类型，开发过程中常常会遇到需要检测数据类型的情况，但是JavaScript提供给我们的方法效果各有优劣，本文分析了<strong>四种</strong>检测数据类型的方法，并在文章末尾提供了一种组合判断的思路。</p>
<h2 id="二-方法">二、方法</h2>
<h3 id="21-typeof">2.1 typeof</h3>
<pre><code class="language-js">typeof   123　　 	//&quot;number&quot;
typeof   'abc'　　//&quot;string&quot;
typeof    true       //&quot;boolean&quot;
typeof    undefined   //&quot;undefined&quot;
typeof    Symbol('a')   //&quot;symbol&quot;
typeof    null        //&quot;object&quot;
typeof    { }           //&quot;object&quot;
typeof    [ ]           //&quot;object&quot;
typeof    console.log()       //&quot;function&quot;
</code></pre>
<p>对于<strong>基本类型</strong>：</p>
<ul>
<li>
<p>对 <code>null</code>使用返回 <code>&quot;object&quot;</code></p>
</li>
<li>
<p>对其他使用返回其<strong>字符串</strong>形式的<strong>类型名</strong></p>
</li>
</ul>
<p>对于<strong>引用类型</strong>：</p>
<ul>
<li>
<p>对 function 使用返回 <code>&quot;function&quot;</code></p>
</li>
<li>
<p>对其他引用数据类型返回 <code>&quot;object&quot;</code></p>
</li>
</ul>
<h3 id="22-instanceof">2.2 instanceof</h3>
<p><code>instanceof</code> 用于判断某个变量是否是某种类型的实例，返回结果是一个<strong>布尔值</strong>，需要两个参数：<code>a incetance of B</code>中，<code>a</code>是待判断的变量， <code>B</code>是作为判断标准的<strong>引用类型</strong>。</p>
<pre><code class="language-js">let a=[]
a instanceof Array //true
a instanceof Object //true
</code></pre>
<p>「<strong>本质上<code>a instanceof B</code>判断的是 <code>a</code>的原型链上是否存在<code>B.prototype</code></strong>」，但无法判断<code>a</code><strong>直接所属</strong>的类型。所以在上面的例子中，<strong><code>a</code> 是<code>Array</code>的实例，也是<code>Object</code>的实例</strong>。</p>
<p>另外对于使用字面量方法定义的基本数据类型，使用 <code>instanceof</code>来判断它们「<strong>是否是某包装类型的实例</strong>」会返回 <code>false</code>，这在<strong>技术是是完全正确的</strong>，但在实际使用中作为基本类型的判断符就不太理想，如下所示：</p>
<pre><code class="language-js">let b = 1
b instanceof Number //false

let c = &quot;c&quot;
c instanceof String //false

let d = true
d instanceof Boolean //false
</code></pre>
<p><code>instanceof</code> 操作符还有一个问题在于，它<strong>假定只有一个全局执行环境</strong>。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</p>
<pre><code class="language-js">var iframe = document.createElement('iframe');
document.body.appendChild(iframe);
IframeArray = window.frames[0].Array;
var arr =new IframeArray(1,2,3);// [1,2,3]
arr instanceof Array;// false
</code></pre>
<p>针对数组的这个问题，<strong>ES5</strong> 提供了 <code>Array.isArray()</code> 方法 。该方法用以确认某个对象本身是否为 <code>Array</code> 类型，而不区分该对象在哪个环境中创建。</p>
<pre><code class="language-js">if(Array.isArray(arr)){
   //对数组执行某些操作
}
</code></pre>
<p><code>Array.isArray()</code>本质上检测的是对象的 <code>[[Class]]</code> 值，<code>[[Class]]</code> 是对象的一个内部属性，里面包含了对象的类型信息，其格式为 <code>[object Xxx]</code> ，<code>Xxx</code> 就是对应的具体类型 。对于数组而言，<code>[[Class]]</code> 的值就是 <code>[object Array]</code>，所以这里直接使用方法四中的<code>Object.prototype.toString.call(arr)</code>也是可以的 。</p>
<h3 id="23-constructor">2.3 constructor</h3>
<p><code>constructor</code>访问的是<strong>对象原型</strong>上的<code>cosntructor</code>属性，使用方法如下：</p>
<pre><code class="language-js">let a=[]
a.constructor //ƒ Array() { [native code] }
a.constructor == Array //true

let b=1
b.contructor == Number //true

let c=&quot;str&quot;
c.constructor == String //true

let d=true
d.constructor == Boolean //true
</code></pre>
<p>但是这里发生了一件很奇怪的事，不同于<code>incetanceof</code>的判断结果，为什么使用<code>constructor</code>可以正确地判断基本类型？参考《JavaScript 高级程序设计》对<strong>基本包装类型</strong>的解释，</p>
<blockquote>
<p>在读取模式中访问字符串（或数字、布尔值）时，后台都会自动完成下列处理。<br>
(1) 创建String类型的一个实例；<br>
(2) 在实例上调用指定的方法；<br>
(3) 销毁这个实例。</p>
</blockquote>
<p>所以，事实上这里的<code>b.contructor</code>访问的是后台<strong>临时</strong>创建的基本包装类型的<code>constructor</code>属性。</p>
<p>这种方法有<strong>两个缺陷</strong>：</p>
<ol>
<li>
<p><code>null</code>和 <code>undefined</code>是没有 <code>constructor</code>属性的，所以无法通过这种方法判断</p>
</li>
<li>
<p>函数的 <code>constructor</code>是不稳定的，这个主要体现在自定义对象上，当开发者重写 <code>prototype</code>后，原有的 <code>constructor</code><strong>引用会丢失</strong>，<code>constructor</code>变为重写的<code>prototype</code>的<code>constructor</code>。（重写<code>prototype</code>为 <code>Number</code>实例，则此后新建的<code>Parent</code>实例的<code>constructor</code>变为<code>Number</code>，如下所示）</p>
</li>
</ol>
<pre><code class="language-js">function Parent(){}

let a = new Parent()
a.constructor == Parent //true

Parent.prototype = {prop:&quot;new prototype props&quot;}

let b = new Parent()
b.constructor == Parent //false
b.constructor == Object //true

Parent.prototype = new Number()

let c = new Parent()
c.constructor == Parent //false
c.constructor == Number //true
</code></pre>
<p>《JavaScript 高级程序设计》提供了一种解决方案，在重写原型的同时将<code>constructor</code>属性覆盖为需要的值：</p>
<pre><code class="language-js">function Parent(){}

Parent.prototype = {
    constructor: Parent,
    props:&quot;new prototype props&quot;
}

let a = new Parent()
a.constructor == Parent //true
</code></pre>
<blockquote>
<p><strong>注意</strong>，以这种方式重设<code>constructor</code>属性会导致它的<code>[[Enumerable]]</code>特性被设置为<code>true</code>。</p>
</blockquote>
<h3 id="24-tostring">2.4 toString</h3>
<p><code>toString()</code> 是 <code>Object</code> 的原型方法，调用该方法，默认返回当前对象的 <code>[[Class]]</code>。这是一个内部属性，其格式为 <code>[object Xxx]</code> ，其中<code>Xxx</code>就是对象的类型。对于 <code>Object</code>对象，直接调用 <code>toString()</code> 就能返回 <code>[object Object]</code> 。而对于其他对象，则需要通过 <code>call() / apply()</code> 来调用才能返回正确的类型信息。</p>
<pre><code class="language-js">Object.prototype.toString.call('') ;  // [object String]Object.prototype.toString.call(1) ;   // [object Number]Object.prototype.toString.call(true) ;// [object Boolean]Object.prototype.toString.call(Symbol());//[object Symbol]Object.prototype.toString.call(undefined) ;// [object Undefined]Object.prototype.toString.call(null) ;// [object Null]Object.prototype.toString.call(function Function(){}) ;// [object Function]Object.prototype.toString.call(new Date()) ;// [object Date]Object.prototype.toString.call([]) ;// [object Array]Object.prototype.toString.call(new RegExp()) ;// [object RegExp]Object.prototype.toString.call(new Error()) ;// [object Error]Object.prototype.toString.call(document) ;// [object HTMLDocument]Object.prototype.toString.call(window) ;//[object global] window 是全局对象 global 的引用
</code></pre>
<p>这种方法可以准确的判断<strong>所有基本类型和原生引用类型</strong>，但是并<strong>不能用于判断自定义类型</strong>。</p>
<pre><code class="language-js">function Parent(){}let a = new Parent()Object.prototype.toString.call(a) //[object Object]
</code></pre>
<h2 id="三-总结">三、总结</h2>
<ol>
<li><code>typeof</code> 不可用于判断<code>null</code>，以及「<code>function</code>以外的<strong>引用类型</strong>」</li>
<li><code>instanceof</code> 用于判断「后者的原型是否在前者的<strong>原型链</strong>上」</li>
<li><code>constructor</code> 无法用于判断<code>null</code>和<code>undefined</code>，因为他们不具有<code>constructor</code>属性; 重写<code>prototype</code>时<code>constructor</code>会丢失</li>
<li><code>toString()</code> 不可用于判断<strong>原生引用类型</strong>之外的「<strong>自定义类型</strong>」</li>
</ol>
<p>可以看到每种方法都有各自的优势和缺陷，针对具体需求的不同，我们可以灵活的使用某一种方法，或者结合多种方法来达成目的。这里提供一种思路：</p>
<ol>
<li>
<p>第一步，使用<code>toString</code>进行判断，若为<strong>基本类型</strong>或<strong>原生引用类型</strong>，可以直接输出结果</p>
</li>
<li>
<p>第二步，对于第一步判断结果为<code>[object Object]</code>的<strong>自定义引用类型</strong>，使用<code>constructor</code>进行二次判断</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何使用 JavaScript 扁平化数组？]]></title>
        <id>https://davidyangblog.github.io/post/ru-he-shi-yong-javascript-bian-ping-hua-shu-zu/</id>
        <link href="https://davidyangblog.github.io/post/ru-he-shi-yong-javascript-bian-ping-hua-shu-zu/">
        </link>
        <updated>2021-06-08T02:40:30.000Z</updated>
        <summary type="html"><![CDATA[<p>「如何」系列第三篇，分享了6个JS扁平化数组的方法，总结了3个核心思想。</p>
]]></summary>
        <content type="html"><![CDATA[<p>「如何」系列第三篇，分享了6个JS扁平化数组的方法，总结了3个核心思想。</p>
<!-- more -->
<h1 id="一-数组扁平化">一、数组扁平化</h1>
<p>数组扁平化就是将多维数组转化为一维数组：</p>
<pre><code class="language-javascript">let arr = [1, [2, 3, [4, 5]]]  ——&gt;  [1, 2, 3, 4, 5]
</code></pre>
<h2 id="11-tostring-split">1.1  <code>toString</code>+ <code>split</code></h2>
<p>先将数组转化为字符串，再使用split将字符串转化为数组：</p>
<pre><code class="language-javascript">let arr = [1, [2, 3, [4, 5]]]
function flatten(arr) {
    return arr.toString().split(',')
}
console.log(flatten(arr)) 
</code></pre>
<p>用split形成的数组的每个元素仍然是字符串，需要将其转化为数字</p>
<p><strong>缺陷</strong>：若元素为字符串且包含「 , 」，则 <code>split</code>方法不能正确分割。</p>
<h2 id="12-reduce">1.2 <code>reduce</code></h2>
<p>reduce方法会对根据回调函数对数组的每个元素进行操作：</p>
<pre><code class="language-javascript">let arr = [1, [2, 3, [4, 5]]] 
const newArr = function(arr){
  return arr.reduce((pre,cur)=&gt;pre.concat(Array.isArray(cur)?newArr(cur):cur),[])
}
console.log(newArr(arr)); 
</code></pre>
<p>更多<code>reduce()</code>方法的使用：<a href="https://blog.csdn.net/qq_42033567/article/details/107902216">《数组reduce()方法的妙用》</a></p>
<h2 id="13-joinsplit">1.3 <code>join</code>+<code>split</code></h2>
<p><code>join()</code>方法和上面的<code>toString</code>方法类似，都能将数组转化为字符串</p>
<pre><code class="language-javascript">let arr = [1, [2, 3, [4, 5]]] 
function flatten(arr) {
    return arr.join(',').split(',')
}
</code></pre>
<p><strong>注意</strong>：若被扁平化的数组由<strong>数字</strong>构成，<code>join</code>在扁平化数组的同时，使用传入的第一个参数作为分隔符，输出的是扁平化后的数组字符串，所以需要先用<code>split</code>切分转为字符串数组，再对每个元素进行转数字操作。</p>
<h2 id="14-递归-循环">1.4 递归 + 循环</h2>
<pre><code class="language-js">function myFlat(arr){
    let res = []
    arr.map(item=&gt;{
        if(Array.isArray(item)){
            res = res.concat(myFlat(item))
        } else {
            res.push(item)
        }
    })
    return res
}
</code></pre>
<h2 id="15-拓展运算符">1.5 拓展运算符</h2>
<p>对数组进行多次判断，若有任意元素是数组，则使用<code>...</code>将其解构一次，反复执行以上过程，直至数组扁平化完成。</p>
<blockquote>
<ul>
<li>
<p><code>Array.some</code>返回一个<code>Boolean</code>值，表示数组中是否有任一元素通过测试函数</p>
</li>
<li>
<p><code>...</code>扩展运算符可以取出参数的所有的可以遍历的对象，并拷贝到当前的对象中</p>
</li>
</ul>
</blockquote>
<pre><code class="language-javascript">let arr = [1, [2, 3, [4, 5]]] 
function myFlat(arr) {
    while (arr.some(item =&gt; Array.isArray(item))) {
        arr = [].concat(...arr);
    }
    return arr;
}
console.log(myFlat(arr)); 
</code></pre>
<h2 id="16-flat">1.6 <code>flat</code></h2>
<p><code>flat()</code>是 ES6 中的一个数组方法，该方法会按照一个可指定的深度depth递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>
<p>语法： <code>let newArray = arr.flat(depth)</code></p>
<p><strong>注意：</strong></p>
<ul>
<li>该方法不会改变原数组</li>
<li><code>depth</code>为指定要提取嵌套数组的结构深度，默认值为 1</li>
<li><code>flat()</code> 方法会移除数组中的空项</li>
</ul>
<pre><code class="language-js">let arr1 = [1, 2, [3, 4]];
arr1.flat(); 
//[1, 2, 3, 4]

let arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat(1); 
// [1, 2, 3, 4, [5,6]]

let arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2); 
// [1, 2, 3, 4, 5, 6]


let arr4 = [1, 2, [3, 4, [5, 6]]]
arr4.flat(Infinity); 
//[1,2,3,4,5,6]

let arr5 = [1, 2, , 4, 5];
arr5.flat(); 
//[1,2,4,5]
</code></pre>
<h1 id="二-归纳">二、归纳</h1>
<p>数组扁平化方法的核心思想，我总结了以下三种</p>
<h2 id="21-层次思想">2.1 层次思想</h2>
<p>分别实现两个方法</p>
<ul>
<li>
<p>浅扁平化方法：只扁平化一层数组</p>
<p>例如：</p>
<pre><code class="language-js">function shallowFlatten(arr) {
  return [].concat(...arr)
}
</code></pre>
</li>
<li>
<p>深扁平化方法：<strong>迭代</strong>执行浅扁平化方法</p>
<pre><code class="language-jsx">function deepFlatten(arr,deepth){
  let result = arr
  while(n--){
    result = shallowFlatten(result)
  }
  return result 
}
</code></pre>
<p>使用方法和<code>flat</code>类似</p>
<pre><code class="language-js">let arr = [1, [2, 3, [4, 5]]]
deepFlatten(arr,1)
//[1,,2,3,[4,5]]
deepFlatten(arr,2)
//[1,2,3,4,5]
</code></pre>
</li>
</ul>
<p>上文提到的 <code>1.5 拓展运算符</code> 使用了这种思想。</p>
<h2 id="22-递归思想">2.2 递归思想</h2>
<p><code>1.2 reduce</code>、<code>1.4 递归 + 循环</code>都是递归思想的不同实现，根据数组方法的使用差异，还可以有更多种实现，篇幅有限，不一一列举。</p>
<p>这里用<code>1.2 reduce</code>作为例子描述一下递归的核心思想：</p>
<pre><code class="language-js">function myFlat(arr){
    //定义一个临时数组 res
    let res = []
    //循环遍历原数组
    arr.map(item =&gt;{
        if(Array.isArray(item)){//若当前元素是数组
            //递归使用myFlat方法展开此数组，将返回值和此数组拼接
            res = res.concat(myFlat(item))
        } else {//若当前元素不是数组，则已经访问到最底层
            //将此非数组元素塞入 res 尾部
            res.push(item)
        }
    })
    //返回临时数组
    return res
}
</code></pre>
<h2 id="23-降维打击">2.3 降维打击</h2>
<p><code>1.1 toString + spli</code> 、<code>1.3 join+split</code>属于奇淫巧计，管你原来在第几层，我直接把你拉到第一层：转成字符串，之后再复原成数组。不过这个方法有个缺点，就是原来的空数组转的<strong>空字符串</strong>也会被放入新生成的数组里去。如果不需要空字符串元素，就需要对结果进行过滤。</p>
<p>除了直接调用它的 <code>toString</code>方法之外，还可以用隐式转换间接调用：</p>
<pre><code class="language-jsx">function flatten(arr){
    return (arr + '').split(',')
}
</code></pre>
<h1 id="三-最后">三、最后</h1>
<p>实际项目中需要使用的话，<code>flat</code>是代码量最小最直接的一种方法；遇上面试考察当然是多多益善。如果考虑到性能，我个人理解<strong>降维打击思想</strong>在理论上性能最好。下一篇文章将和各位一同学习<strong>对象扁平化</strong>。</p>
<p><em><strong>参考：</strong></em></p>
<p><a href="https://www.cnblogs.com/mengfangui/p/9485703.html">js 数组扁平化</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">Array.prototype.reduce()</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some">Array.prototype.some()</a></p>
<p><a href="https://www.jianshu.com/p/b1fb3434e1f5">JS 扁平化（flatten） 数组</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何使用Redux？]]></title>
        <id>https://davidyangblog.github.io/post/ru-he-shi-yong-redux/</id>
        <link href="https://davidyangblog.github.io/post/ru-he-shi-yong-redux/">
        </link>
        <updated>2021-06-07T02:53:45.000Z</updated>
        <summary type="html"><![CDATA[<p>「如何」系列第二篇，通过一个案例来介绍Redux的用法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>「如何」系列第二篇，通过一个案例来介绍Redux的用法。</p>
<!-- more -->
<h1 id="零-前言">零、前言</h1>
<h2 id="背景">背景</h2>
<p>本次需求中，要求实现培训文档功能。核心功能是：每个任务下对应一定数量的培训文档，具有权限的用户可以进行上传、下载、删除文档三种操作。本文只选择了上传功能为案例，展示通过 Redux 处理数据和更新视图的思路以及代码结构，代码省略了业务逻辑相关部分。</p>
<h2 id="分析">分析</h2>
<p>Pioneer 项目前端将任务进行了抽象化，定义了一个 Task 类，所有 Task 类的相关操作可以通过其成员方法来实现，同时将修改动作交由 reducer 来实时更新 redux 中的 Task 数据。</p>
<p>由于目前并没有将 Task下的文档共享到其他组件的硬性需求，我这是强行使用 Redux 来熟悉项目，增加自己的工作量，不够闲的朋友请勿尝试。</p>
<p>先复习一下 Redux 的工作流程：<img src="https://gitee.com/yxon123/gitee-sources/raw/master//Images/image-20210609105516763.png" alt="image-20210609105516763" loading="lazy"></p>
<p>根据 Redux 的工作流和业务逻辑，我将要上传培训文档应该会经历以下步骤</p>
<ol>
<li>在 <code>ReactComponent</code>中选择文件（<code>data</code>），点击上传按钮</li>
<li>触发 <code>ActionCreator</code>，调用后端接口，上传 <code>data</code></li>
<li><code>ActionCreator</code>根据调用结果，向 <code>Reducer</code>发送不同 <code>action</code></li>
<li><code>action</code>携带 <code>data</code>进入 <code>Reducer</code></li>
<li><code>Reducer</code>从 <code>store</code> 获取当前 <code>state</code>，根据 <code>actionType</code>对 <code>state</code>进行修改</li>
<li><code>Reducer</code>向 <code>store</code>返回新的 <code>state</code></li>
<li><code>store</code>向 <code>ReactComponent</code>返回 <code>newState</code>（一般为容器组件（<code>Container</code>））</li>
</ol>
<p>前置知识：React, TypeScript</p>
<p>新增知识：Redux Flow, react-redux</p>
<p>拓展知识：<a href="https://www.typescriptlang.org/docs/handbook/enums.html?azure-portal=true">TypeScriptr-enum</a>, MVVM, MVC</p>
<p>以下是思路展示：</p>
<h1 id="一-直接调用后端-api">一、 直接调用后端 API</h1>
<h2 id="server-proxy"><code>server-proxy</code></h2>
<p><strong>引入axios并对其进行封装</strong></p>
<p>在此文件中定义直接调用接口的方法 <code>async uploadDocs()</code></p>
<pre><code class="language-tsx">async function uploadDocs(id, docsData) {
    const { backendAPI } = config;
    //上传文件时，需要用FormData 来构造post的body部分
    const taskData = new FormData();
    taskData.append(`file`, docsData.file);
    taskData.append(`description`,docsData.description);

    try {
        //此处用到了封装过的 axios，也可以采用其他 HTTP 库
        const response = await Axios.post(`${backendAPI}/tasks/${id}/docs`,taskData, {
            proxy: config.proxy,
            headers: {
                'Content-Type': 'application/json',
            },
        });
        return response
    } catch (errorData) {
        throw generateError(errorData);
    }
}
</code></pre>
<h1 id="二-在实例所属类中引入封装好的方法">二、在实例所属类中引入封装好的方法</h1>
<h2 id="session"><code>session</code></h2>
<p><strong>引入 <code>server-proxy</code> 中的方法进行封装</strong></p>
<ol>
<li>在 Task 原型中定义 uploadDocs 方法</li>
</ol>
<pre><code class="language-tsx">Task.prototype.uploadDocs.implementation = async function (data, taskid) {
    const result = await serverProxy.tasks.uploadDocs(data, taskid);
    return result
}
</code></pre>
<ol start="2">
<li>用<code>apiWrapper</code>来调用原型方法</li>
</ol>
<pre><code class="language-tsx">async uploadDocs(id, docsData){
    const result = await PluginRegistry
    .apiWrapper.call(this, Task.prototype.uploadDocs, id, docsData);
    return result;
}
</code></pre>
<p><em>注意：这一整个步骤属于视具体业务而出现的操作，并非 Redux 必要步骤。</em></p>
<h1 id="三-actioncreator-创建-action">三、ActionCreator - 创建 action</h1>
<h2 id="tasks-actions"><code>tasks-actions</code></h2>
<p><strong>定义了和 task 相关的 ActionCreator</strong></p>
<p>在此文件中定义一个返回 <strong>TunkAction</strong> 的函数<code>uploadDocsAsync()</code>（此函数即为 ActionCreator），根据异步操作的执行结果触发相应动作。</p>
<pre><code class="language-tsx">//声明了要用到的 actionTypes
export enum TasksActionTypes {
    //培训文档相关动作
    UPLOAD_DOCS = 'UPLOAD_DOCS',
    UPLOAD_DOCS_SUCCESS = 'UPLOAD_DOCS_SUCCESS',
    UPLOAD_DOCS_FAILED = 'UPLOAD_DOCS_FAILED',
	//...
}

//上传任务的培训文档
export function uploadDocsAsync(data:any):
ThunkAction&lt;Promise&lt;void&gt;, {}, {}, AnyAction&gt; {
    return async (dispatch: ActionCreator&lt;Dispatch&gt;): Promise&lt;void&gt; =&gt; {
        //进入函数，dispatch 触发 UPLOAD_DOCS 动作
        dispatch({ type:TasksActionTypes.UPLOAD_DOCS })
        try {
        //尝试调用 2 中实例方法，上传培训文档
        const res = await taskInstance.uploadDocs(data)
        //成功，dispatch 触发 SUCCESS 动作，传递新的培训文档数据
        dispatch({ type:TasksActionTypes.UPLOAD_DOCS_SUCCESS,payload:{docs:data}})
        } catch (error) {
            //失败，dispatch 触发 FAILED 动作，传递 error 
            dispatch({ type:TasksActionTypes.UPLOAD_DOCS_FAILED,payload:{error:error} })
        }
    };
}
</code></pre>
<h1 id="四-reducer-执行-action-修改-state">四、Reducer - 执行 action 修改 state</h1>
<h2 id="task-reducer"><code>task-reducer</code></h2>
<p><strong>响应 task 相关 action 并改变 state</strong></p>
<p>reducer 文件结构：</p>
<pre><code class="language-ts">import { TasksActionTypes } from 'actions/tasks-actions'; //引入 action 文件
import { TasksState, Task } from './interfaces';//描述 TaskSate 的 ts 文件

const defaultState: TasksState = {
    //...
};

export default (state: TasksState = defaultState, action: AnyAction): TasksState =&gt; {
    switch (action.type) {
        case TasksActionTypes.UPLOAD_DOCS:{
            //...
        }
        case TasksActionTypes.UPLOAD_DOCS_SUCCESS:{
			//...
        }
        case TasksActionTypes.UPLOAD_DOCS_FAILED:{
			//...
        }
        default:
            return state;
    }
};
</code></pre>
<p>在 <code>tasks-reducer</code> 中新增对应三个action 的 case，更新 <code>TasksState</code> 中的 docs 数据和上传状态</p>
<ul>
<li>
<p>UPLOAD_DOCS --- 修改 uploadDocs 的 Status</p>
</li>
<li>
<p>UPLOAD_DOCS_SUCCESS --- 修改 uploadDocs 的 Status &amp; 修改 docs</p>
</li>
<li>
<p>UPLOAD_DOCS_FAILED --- 修改 uploadDocs 的 Status</p>
</li>
</ul>
<pre><code class="language-tsx"> case TasksActionTypes.UPLOAD_DOCS:{
	//...
 }
 case TasksActionTypes.UPLOAD_DOCS_SUCCESS:{
     const { doc } = action.payload;
     const { uploadDocs } = state.activities;

     return {
         ...state,
         docs:[...state.docs,doc],//添加新 doc
         activities: {
             ...state.activities,
             uploadDocs: {
                 ...uploadDocs,
                 status:'UPLOADED'// 修改 status
             },
         },
     };
 }
 case TasksActionTypes.UPLOAD_DOCS_FAILED:{
	//...
 }
</code></pre>
<h2 id="interfacests"><code>interfaces.ts</code></h2>
<p><strong>TypeScript 文件，描述 reducer 中的数据类型</strong></p>
<p>在此文件中定义 uploadDocs 与相关的状态成员</p>
<pre><code class="language-ts">export interface TasksState {
	//...
    activities: {
        //...
        uploadDocs:{
            status:string;
            error:string;
        };
    };
    //...
    docs:TrainDoc[]
}
</code></pre>
<h1 id="五-容器组件container和展示组件">五、容器组件（Container）和展示组件</h1>
<p>经过以上几个步骤，终于可以将上传方法和状态值引入组件了，通过容器组件传递到展示组件，完成渲染。</p>
<h2 id="trainingdocuments"><code>&lt;TrainingDocuments/&gt;</code></h2>
<p>展示组件：只负责页面的渲染和数据绑定，只被其容器组件引用</p>
<h2 id="trainingdocumentscontainer"><code>&lt;TrainingDocumentsContainer/&gt;</code></h2>
<p>容器组件：负责页面的逻辑和状态获取</p>
<p>创建一个 <code>train-doc</code> 组件的 container  <code>&lt;TrainingDocumentsContainer /&gt;</code>，在 Container 中将 dispatch 的操作映射到 Props。</p>
<pre><code class="language-tsx">import { uploadDocsAsync } from 'actions/tasks-actions';//引入第三步中的 action

//定义接口
interface DispatchToProps {
    onUploadDocs(data:object):void
    onGetDocs(taskId:number):void
    onDeleteDocs(taskId:number,docId:number):void
}

//将 dispatch 映射到 Props
function mapDispatchToProps(dispatch: any): DispatchToProps {
    return {
        onUploadDocs: (data: object):void=&gt; dispatch(uploadDocsAsync(data))
    };
}

//这里也可以简写，react-redux 会自动处理
const mapDispatchToProps = {
        onUploadDocs:uploadDocsAsync,
        onGetDocs: getDocsAsync,
        onDeleteDocs: deleteDocsAsync
}

function TrainingDocumentsContainer(props: StateToProps &amp; DispatchToProps &amp; OwnProps): JSX.Element {
    const {
        tasks,//tasks 是在前端 redux 中保存的 TaskState 实例，存储着 task 的状态值，参见第四步中的 interface.ts
        onUploadDocs,
    } = props;
    
    // 上传状态
    const upLoading = (tasks.activities.uploadDocs.status == 'UPLOADING')
    
    // 当前 task 文档列表
	const taskDocs = (tasks.docs)

    // 第一次渲染页面时，先获取一次 task 的状态值
    useEffect(()=&gt;{
        onGetDocs(taskId)
    },[])

    return (
        &lt;TrainingDocuments 
            taskDocs={taskDocs}
            upLoading = {upLoading}
            onUploadDocs = {onUploadDocs}
        /&gt;
    );
}

// 将容器组件与状态连接起来
export default connect(
    mapStateToProps,
    mapDispatchToProps,
)(TrainingDocumentsContainer);
</code></pre>
<h1 id="效果展示">效果展示</h1>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/yxon123/gitee-sources/raw/master//Images/t01bd801d144d21cb41.png" alt="image-20210322115645319" loading="lazy"></figure>
<h1 id="总结">总结</h1>
<p>Redux 不关心数据在视图层面的具体作用，它将所有数据的当前值保存为一个 <code>state</code>，可以理解为数据“快照”。数据的一切变化，即是从旧的<code>state</code>到新的<code>state</code>的变化过程，同时运用中间件 <code>redux-logger</code>，对这个变化过程做一次记录。<strong>概括来说，Redux的思想是把有共享需要的「数据和数据逻辑」与「展示逻辑」进行了分离，将修改数据的操作视为为不同的 <code>action</code>，在每一个 <code>action</code>前后，数据快照 <code>state</code>产生变化。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何用 git 热修复主分支上的 bug？]]></title>
        <id>https://davidyangblog.github.io/post/ru-he-yong-git-re-xiu-fu-zhu-fen-zhi-shang-de-bug/</id>
        <link href="https://davidyangblog.github.io/post/ru-he-yong-git-re-xiu-fu-zhu-fen-zhi-shang-de-bug/">
        </link>
        <updated>2021-06-06T02:52:07.000Z</updated>
        <summary type="html"><![CDATA[<p>「如何」系列第一篇，介绍 git 工具热修复主分支的方法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>「如何」系列第一篇，介绍 git 工具热修复主分支的方法。</p>
<!-- more -->
<h3 id="问题场景">问题场景</h3>
<p>有时候我们需要修复一个线上（位于 <code>master</code>分支）的bug，但又不希望影响本地分支和其他分支。</p>
<h3 id="解决方案">解决方案</h3>
<p>考虑从 <code>master</code>复制一个新分支 <code>master_hotfix</code>，在新分支上完成 bug 修复之后 <code>merge</code> 到 <code>master</code>分支，修复完成后删除 <code>master_hotfix</code>分支</p>
<h3 id="步骤">步骤</h3>
<ol>
<li>
<p><strong>暂存当前工作分支尚未 <code>commit</code> 的内容</strong></p>
<ol>
<li>
<pre><code class="language-bash">git stash save &quot;save message&quot; 
</code></pre>
<p>执行存储时，添加备注，方便查找，只有<code>git stash</code> 也是可以的，但查找时不方便识别</p>
</li>
<li>
<pre><code class="language-bash">git stash show
</code></pre>
<p>显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加<code>stash@{$num}</code>，比如第二个<code>git stash show stash@{1}</code></p>
</li>
</ol>
</li>
<li>
<p><strong>从 <code>master</code> 复制新分支 <code>master_hotfix</code></strong></p>
<ol>
<li>
<pre><code class="language-bash">git checkout master
</code></pre>
<p>切换到 <code>master</code> 分支</p>
</li>
<li>
<pre><code class="language-bash">git checkout -b master_hotfix
</code></pre>
<p>从当前分支（<code>master</code>）复制到新分支开发</p>
</li>
<li>
<pre><code class="language-bash">git branch --set-upstream-to=origin/master_hotfix
</code></pre>
<p>与远程分支进行关联</p>
</li>
<li>
<pre><code class="language-bash">git pull
</code></pre>
<p>拉取验证</p>
</li>
</ol>
</li>
<li>
<p><strong>在远程仓库将 <code>master_hotfix</code> merge 到<code>master</code> 分支</strong></p>
</li>
<li>
<p><strong>删除 <code>master_hotfix</code>分支</strong></p>
<ol>
<li>
<pre><code class="language-bash">git branch -D master_hotfix
</code></pre>
<p>删除本地分支</p>
<p>注：<code>-D</code>是<code>--delete --force</code>的缩写,这样写可以在不检查 merge 状态的情况下删除分支</p>
</li>
<li>
<pre><code class="language-bash">git push origin --delete master_hotfix
</code></pre>
<p>删除远程分支</p>
</li>
<li>
<pre><code class="language-bash">git branch -a
</code></pre>
<p>查看所有分支（本地分支和远程分支），检验是否删除成功</p>
</li>
</ol>
</li>
</ol>
<p><em><strong>参考</strong></em></p>
<p><a href="https://www.jianshu.com/p/5068997164cb">git 删除分支 </a></p>
<p><a href="https://www.cnblogs.com/wangfajun/p/10789231.html">Git复制已有分支到新分支开发</a></p>
]]></content>
    </entry>
</feed>